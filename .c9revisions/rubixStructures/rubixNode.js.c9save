{"ts":1351023133295,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/* -------------\n    RubixNode.js\n    Requires - rubixState.js\n    A node representation of state for search trees.\n   --------------*/\n\nRubixNode.statePool = [];\nRubixNode.nodePool = [];\nRubixNode.faceCulling = {\n    \"0\":4,\n    \"1\":3,\n    \"2\":5\n};\n\n/**\n * Defines an object to represent a node on the IDA* search tree for a rubik's cube.\n * @param state The state to be wrapped by the node.\n * @param parent Optional - The parent used in retrieving the path.\n * @param action Optional - The action that was taken to reach this node.\n *          Has the following bit pattern: -###-@@@ where -:null #:face @:rotations\n * \n */\nfunction RubixNode(state, parent, face, rots)\n{\n    this.init(state,parent,face, rots);    \n}\n\nRubixNode.prototype.init = function(state, parent, face, rots)\n{\n    this.rubixState = state;\n    \n    this.nodeAction = null;\n\n    if(face >= 0 && rots >= 0 )\n    {\n        this.nodeAction =  ((0 | face) << 4) | rots;\n   \n    }  \n    \n    this.parentNode = parent;\n    \n    \n    if (parent)\n    {        \n        this.depth = parent.depth + 1;\n        this.fn = this.depth + CubeHeuristics.heuristic(this.rubixState);\n\n        parent.rc ++;\n    }\n    else\n    {\n        this.depth = 0;\n        this.fn = CubeHeuristics.heuristic(this.rubixState);\n        this.rc = 0;\n    }\n};\n    \n   \n\n/**\n * Retrieves and generates nodes for all possible states that may follow the \n * invoking node's state.\n * \n * @param node The node to retrieve successors for.\n * @return The array of successors for the rubix cube, if a solution is found \n *         within the array return the solution alone in an array.\n */\nRubixNode.getSuccessors = function(node)\n{\n    //Initialize placeholders\n    var successors = [];\n    \n    // For each face iterate over the three possible movements for the cube and \n    // Record them.\n    for(var i = 0; i < 6; i++)\n    {\n        if(node.nodeAction && i === node.nodeAction >> 4)\n        {\n            continue;\n        }\n        \n        for(var j = 1; j < 4; j++)\n        {\n            if(node.nodeAction && RubixNode.faceCulling[(node.nodeAction >> 4)] == i \n               && (2 - (node.nodeAction & 7 - 2)) == j)\n            {\n               continue;\n            }\n        // Create a new node with a copy of the data then rotate the state.            \n            successors.push(\n                RubixNode.buildNode(RubixNode.nodePool.pop(),\n                                    RubixState.copyAndRotate(node.rubixState, \n                                        RubixNode.statePool.pop(), i,j), \n                                    node, i, j));\n        }   \n    }    \n\n    return successors;\n};\n\nRubixNode.buildNode  = function(node, state, parentNode, face, rots)\n{\n    if(node)\n    {\n        node.init(state,parentNode, face, rots);\n    }\n    else\n    {\n        node = new RubixNode(state, parentNode,  face, rots);\n    }\n        \n    return node;\n};\n\nRubixNode.wipeBadChain = function(node)\n{\n    if(node.parentNode)\n    {   \n        node.parentNode.rc--;\n        if(node.parentNode.rc === 0 && node.parentNode.depth !== 0)\n        {\n            RubixNode.wipeBadChain(node.parentNode);    \n        }\n        RubixNode.statePool.push(node.rubixState);\n        \n        node.rubixState = null;\n        node.parentNode = null;    \n        node.nodeAction = null;\n        node.rc = null;\n        node.depth = null;\n        node.fn = null;\n        RubixNode.nodePool.push(node);\n    }\n    \n};\n\n/**\n * Returns a String with the node action pair for the supplied node.\n * \n * @param node the node that the action is to be retrieved from.\n * @return A String \"face:rotations\".\n */\nRubixNode.nodeActionToString = function(node)\n{\n  return RubixState.faceValues[node.nodeAction >> 4] + \":\" + (node.nodeAction & 7);  \n};\n"]],"start1":0,"start2":0,"length1":0,"length2":3764}]],"length":3764}
{"contributors":[],"silentsave":false,"ts":1351117412486,"patch":[[{"diffs":[[0,"ion >> 4"],[1," || \n            (i > 2  && RubixNode.faceCulling[(node.nodeAction >> 4)] == i))"],[0,")\n      "]],"start1":1912,"start2":1912,"length1":16,"length2":96}]],"length":3844,"saved":false}
{"ts":1351117416713,"patch":[[{"diffs":[[0,"tion && "],[1,"("],[0,"i === no"]],"start1":1886,"start2":1886,"length1":16,"length2":17}]],"length":3845,"saved":false}
{"ts":1351117421512,"patch":[[{"diffs":[[0,"  {\n"],[-1,"            if(node.nodeAction && RubixNode.faceCulling[(node.nodeAction >> 4)] == i \n               && (2 - (node.nodeAction & 7 - 2)) == j)\n            {\n               continue;\n            }\n"],[0,"    "]],"start1":2095,"start2":2095,"length1":203,"length2":8}]],"length":3650,"saved":false}
