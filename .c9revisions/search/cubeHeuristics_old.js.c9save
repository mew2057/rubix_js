{"ts":1350431624817,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/* ----------\r\n   cubeHeuristics.js\r\n   ---------- */\r\n\r\nfunction CubeHeuristics() {}\r\n\r\nCubeHeuristics.goalState = RubixState.createWithGoalState();\r\n\r\nCubeHeuristics.heuristic = function(rubixState)\r\n{\r\n    return Math.max(CubeHeuristics.manhattanDistanceOfSides(rubixState),\r\n                    CubeHeuristics.manhattanDistanceOfCorners(rubixState));\r\n};\r\n\r\n/* \r\nNote if a corner cubie is in the right position but the faces are wrong, it will\r\ntake at least 2 moves to right it. 3 moves for sides.\r\n*/\r\n\r\nCubeHeuristics.manhattanDistanceOfSides = function(rubixState)\r\n{\r\n    var sum = 0, moves = 0, goalIndex, farSides;\r\n    \r\n    for (var index = 0; index < rubixState.cubies.length; index++)\r\n    {\r\n        if (rubixState.cubies[index].isCorner())\r\n            continue;\r\n        \r\n        moves = 0;\r\n        goalIndex = CubeHeuristics.goalState.findCubie(rubixState.cubies[index]);\r\n        farSides = CubeHeuristics.farSides[index];\r\n        \r\n        // If it's a far side, need at least 2 moves to correct it's position.\r\n        if (farSides.indexOf(goalIndex) !== -1)\r\n            moves = 2;\r\n        // Otherwise, if it's not already in the correct position.\r\n        else if (index !== goalIndex)\r\n            moves = 1;\r\n        \r\n        // Check orientation\r\n        if (moves === 0)\r\n        {\r\n            if (!rubixState.cubies[index].equals(CubeHeuristics.goalState.cubies[index]))\r\n                moves += 3;\r\n        }\r\n        else if (moves === 1)\r\n        {\r\n            // Rotate to correct position and check orientation.\r\n        }\r\n        \r\n        sum += moves;\r\n    }\r\n    \r\n    // TODO - orientation - I think if the orientation doesn't match, it is still\r\n    //   admissible to assume 1 extra move is needed if its distance away is less than 1.\r\n    //   Also, the only way to do this, at least from what I can see is to perform\r\n    //   the rotation to correct it's position, then determine if the orientation is correct.\r\n    \r\n    return sum / 4;\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfCorners = function(rubixState)\r\n{\r\n    var sum = 0, moves = 0, goalIndex;\r\n    \r\n    for (var index = 0; index < rubixState.cubies.length; index++)\r\n    {\r\n        if (rubixState.cubies[index].isSide())\r\n            continue;\r\n        \r\n        moves = 0;\r\n        goalIndex = CubeHeuristics.goalState.findCubie(rubixState.cubies[index]);\r\n        \r\n        // If it's a far corner, need at least 2 moves to correct it's position.\r\n        if (CubeHeuristics.farCorners[index] === goalIndex)\r\n            moves = 2;\r\n        // Otherwise, if it's not already in the correct position.\r\n        else if (index !== goalIndex)\r\n            moves = 1;\r\n        \r\n        // Check orientation\r\n        if (moves === 0)\r\n        {\r\n            if (!rubixState.cubies[index].equals(CubeHeuristics.goalState.cubies[index]))\r\n                moves += 2;\r\n        }\r\n        else if (moves === 1)\r\n        {\r\n            // Rotate to correct position and check orientation.\r\n        }\r\n        \r\n        sum += moves;\r\n    }\r\n    \r\n    // TODO - orientation - See above\r\n    \r\n    return sum / 4;\r\n};\r\n\r\n/**\r\n * A map defining the far corner of the given corner (i.e. the corner it will\r\n * take 2 moves to reach).\r\n */\r\nCubeHeuristics.farCorners = {\r\n    0  : 14,\r\n    2  : 12,\r\n    5  : 19,\r\n    7  : 17,\r\n    12 : 2,\r\n    14 : 0,\r\n    17 : 7,\r\n    19 : 5\r\n};\r\n\r\n/**\r\n * A map defining the far sides of the given side (i.e. the sides it will\r\n * take 2 moves to reach). They are not in any particular order.\r\n */\r\nCubeHeuristics.farSides = {\r\n    1  : [16, 15, 13, 10, 9],\r\n    3  : [10, 13, 16, 18, 11],\r\n    4  : [8, 18, 15, 9, 13],\r\n    6  : [15, 8, 18, 11, 16],\r\n    8  : [13, 16, 10, 4, 6],\r\n    9  : [1, 4, 11, 18, 16],\r\n    10 : [1, 3, 8, 15, 18],\r\n    11 : [3, 6, 9, 13, 15],\r\n    13 : [3, 8, 1, 4, 11],\r\n    15 : [1, 11, 4, 10, 6],\r\n    16 : [6, 9, 3, 8, 1],\r\n    18 : [4, 10, 6, 9, 3]\r\n};"]],"start1":0,"start2":0,"length1":0,"length2":3922}]],"length":3922}
