{"ts":1351183272232,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/* ---------------\n    iterativeAStar.js    \n    Requires - priorityQueue.js, rubixNode.js, rubixState.js\n    A script for running the IDA* algorithm described in korf's paper.\n   ----------------*/\nAStar.goalState = RubixState.createWithGoalState();\n\nfunction AStar()\n{\n    this.frontier = new PriorityMinQueue();\n}\n\n/**\n * Runs IDA* on a RubixState object supplied by the user.\n * \n * @param initialState A valid RubixState to find a solution to.\n * @return A string containing the necessary sequence of moves to achieve a goal state.\n */\nAStar.prototype.iterativeAStar = function(initialState)\n{\n    if(!initialState)\n        return \"Bad Cube\";\n    var sequence =\"\";\n    var depth = 0;\n    var goalNode = null;\n    /*\n    for (var i = 0; i < 6; i ++)\n    {\n        RubixState.rotate(initialState,Math.floor(Math.random()*6), Math.floor(Math.random()*3 + 1));  \n    }*/\n    \n    console.log(RubixState.toString(initialState));\n\n    var initialNode = new RubixNode(initialState);\n    \n    \n    depth = initialNode.fn;\n    console.log(depth);\n    while(!goalNode)\n    {\n        //TODO get Garbage collection to run here...\n        for(var index in this.record)\n        {\n            this.record.pop().parent = null;    \n        }\n        \n        if(RubixState.isEqual(initialState,AStar.goalState))\n        {\n            goalNode = initialState;\n        } \n        else\n        {\n            goalNode = this.iterativeAStarDepthLimted(new RubixNode(initialState),depth);\n        }\n        \n        depth ++;\n        this.frontier = new PriorityMinQueue();\n        \n        if(!goalNode)\n        {    \n            $(\"#outputDiv\").text(\"The depth steadily increased:\" + depth);\n\n            console.log(\"The depth steadily increased:\" + depth);\n        }\n            \n    }\n    \n    console.log(this.pathFromNode(goalNode));\n    sequence =this.pathFromNode(goalNode);\n    \n    return sequence;\n};\n\n/**\n * @brief Performs the IDA* search using a do while loop and Priority min queue. \n * \n * Each iteration of the search checks to see if the current node f(n) is less than\n * the limit imposed by the depth. If this evaluates to true new nodes may be spawned.\n * The spawned nodes are then added to a min priority queue if their f(n) does not exceed the\n * depth. The frontier is then checked if it is empty and if not a new node is \n * pulled from the priority queue. The loop is exited if the priority queue is empty\n * or a goal state is found.\n * \n * @param currentNode The initial node containing the state to find a solution for.\n * @param depth The noninclusive maximum f(n) of a node that may be expanded.\n * \n * @return The goal node if found or null.\n */\nAStar.prototype.iterativeAStarDepthLimted = function(currentNode, depth)\n{      \n    var localNode = currentNode;\n    var isGoal = false;\n    var successors = null, size = 0, index = 0;\n\n    do {\n        if(localNode.fn < depth)\n        {\n            successors = RubixNode.getSuccessors(localNode);        \n            \n            for (index = 0, size = successors.length; index< successors.length; index++)\n            {        \n                if(successors[index].fn <= depth)\n                {\n                    this.frontier.insert(successors[index].fn, successors[index]);    \n                }\n                else\n                {        \n                    RubixNode.wipeBadChain(successors[index]);   \n                }\n            }\n        }\n        else\n        {\n            RubixNode.wipeBadChain(localNode);\n        }\n        \n        \n        if(!this.frontier.isEmpty())\n        {\n            //this.record.push(localNode);\n            localNode = null;\n            localNode = this.frontier.remove(); \n        }\n        \n        isGoal = RubixState.isEqual(localNode.rubixState, AStar.goalState);\n\n       console.log(\"popped\");\n    }while(!this.frontier.isEmpty() && !isGoal);\n    \n    return isGoal ? localNode : null;  \n};\n\n/**\n * Recursively generates a path from the goal node.\n * \n * @param node The goal node the path is reuired from.\n * @return The string containing the sequence.\n */\nAStar.prototype.pathFromNode = function(node)\n{\n    // If the depth is > 1 recursion must be done.\n    // else if the depth is 1 the action sequence is done.\n    // else the cube was already solved when it reached this search.\n    if (node.depth > 1)\n    {\n        return this.pathFromNode(node.parentNode) + \", \" + RubixNode.nodeActionToString(node);\n    }\n    else if (node.depth === 1) \n    {\n        return RubixNode.nodeActionToString(node);\n    }\n    else\n    {\n        return \"It was already solved!\";\n    }\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":4597}]],"length":4597}
{"contributors":[],"silentsave":false,"ts":1351200320884,"patch":[[{"diffs":[[0,"    }*/\n    "],[1,"   RubixState.rotate(initialState,0,1);\n        RubixState.rotate(initialState,1,1);\n        RubixState.rotate(initialState,2,1);\n        RubixState.rotate(initialState,3,1);\n        RubixState.rotate(initialState,4,1);\n        RubixState.rotate(initialState,5,1);\n        RubixState.rotate(initialState,0,1);\n        RubixState.rotate(initialState,1,2);\n        RubixState.rotate(initialState,2,2);\n        RubixState.rotate(initialState,3,2);\n        RubixState.rotate(initialState,4,2);"],[0,"\n    console"]],"start1":864,"start2":864,"length1":24,"length2":513}]],"length":5086,"saved":false}
{"ts":1351205290616,"patch":[[{"diffs":[[0,"}*/\n"],[-1,"       RubixState.rotate(initialState,0,1);\n        RubixState.rotate(initialState,1,1);\n        RubixState.rotate(initialState,2,1);\n        RubixState.rotate(initialState,3,1);\n        RubixState.rotate(initialState,4,1);\n        RubixState.rotate(initialState,5,1);\n        RubixState.rotate(initialState,0,1);\n        RubixState.rotate(initialState,1,2);\n        RubixState.rotate(initialState,2,2);\n        RubixState.rotate(initialState,3,2);\n        RubixState.rotate(initialState,4,2);\n"],[0,"    "]],"start1":868,"start2":868,"length1":502,"length2":8}]],"length":4592,"saved":false}
