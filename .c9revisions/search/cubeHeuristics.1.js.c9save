{"ts":1351023133407,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/* ----------\r\n   cubeHeuristics.js\r\n   ---------- */\r\n\r\nfunction CubeHeuristics() {}\r\n\r\nCubeHeuristics.goalState = RubixState.createWithGoalState();\r\n\r\nCubeHeuristics.corners = [0, 2, 5, 7, 12, 14, 17, 19];\r\n//6\r\nCubeHeuristics.edges = [9, 10, 13, 15, 16, 18, 1, 3, 4, 6, 8, 11];\r\n/*\r\n\r\nCubeHeuristics.edgesTop = [9, 10, 13, 15, 16, 18];\r\nCubeHeuristics.edgesBottom = [1, 3, 4, 6, 8, 11];*/\r\nCubeHeuristics.test = function()\r\n{\r\n    console.log(\"TEST\");\r\n    var rubix = RubixState.createWithGoalState();\r\n    \r\n    var face, rots;\r\n    \r\n    \r\n    for (var i = 0; i < 100; i++)\r\n    {\r\n        face = Math.floor(Math.random() * 6);\r\n        rots = Math.floor(Math.random() * 3 + 1);\r\n        \r\n        RubixState.rotate(rubix, face, rots);        \r\n    }\r\n    \r\n    //RubixState.rotate(rubix, 2, 1);\r\n    \r\n    console.log(RubixState.toString(rubix));\r\n    \r\n    var cornersH = CubeHeuristics.manhattanDistanceOfCorners(rubix);\r\n    var edgesTopH = CubeHeuristics.manhattanDistanceOfTopEdges(rubix);\r\n    var edgesBotH = CubeHeuristics.manhattanDistanceOfBottomEdges(rubix);\r\n    \r\n    console.log(\"Corners:  \" + cornersH);\r\n    console.log(\"EdgesTop: \" + edgesTopH);\r\n    console.log(\"EdgesBot: \" + edgesBotH);\r\n    console.log(\"EdgesAll: \" + CubeHeuristics.manhattanDistanceOfAllEdges(rubix));\r\n    console.log(\"Table H:  \" + Math.max(cornersH, edgesTopH, edgesBotH));\r\n};\r\n\r\nCubeHeuristics.heuristic = function(rubixState)\r\n{\r\n    return Math.max(CubeHeuristics.manhattanDistanceOfAllEdges(rubixState),\r\n                    CubeHeuristics.manhattanDistanceOfCorners(rubixState));\r\n};\r\n\r\n/* \r\nNote if a corner cubie is in the right position but the faces are wrong, it will\r\ntake at least 2 moves to right it. 3 moves for sides.\r\n*/\r\n\r\nCubeHeuristics.manhattanDistanceOfTopEdges = function(rubixState)\r\n{\r\n    return CubeHeuristics.manhattanDistanceOfEdges(rubixState, CubeHeuristics.edges,0,6);\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfBottomEdges = function(rubixState)\r\n{\r\n    return CubeHeuristics.manhattanDistanceOfEdges(rubixState, CubeHeuristics.edges,6,6);\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfAllEdges = function(rubixState)\r\n{\r\n    return CubeHeuristics.manhattanDistanceOfEdges(rubixState,CubeHeuristics.edges, 0,12) //CubeHeuristics.edgesBottom.concat(CubeHeuristics.edgesTop));\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfEdges = function(rubixState, edges,offset, size)\r\n{\r\n    var sum = 0, moves = 0, cubieIndex, goalIndex;//, rotation, alternateState, cubiesEqual;\r\n    \r\n    for (var index = offset; index < offset+size; index++)\r\n    {        \r\n        moves = 0;\r\n        \r\n        cubieIndex = RubixState.findCubie(CubeHeuristics.goalState, edges[index], rubixState);\r\n        goalIndex = RubixState.findCubie(rubixState, cubieIndex, CubeHeuristics.goalState);\r\n        \r\n        // If it's a far side, need at least 2 moves to correct it's position.\r\n        if ( CubeHeuristics.farSides[cubieIndex].indexOf(goalIndex) !== -1)\r\n            moves = 2;\r\n        // Otherwise, if it's not already in the correct position.\r\n        else if (cubieIndex !== goalIndex)\r\n            moves = 1;\r\n        \r\n        // Check orientation\r\n        if (moves === 0) // Correct position but not necessarily orientation\r\n        {\r\n            if (!(RubixState.areCubiesEqual(rubixState, CubeHeuristics.goalState, cubieIndex)))\r\n                moves += 3;\r\n        }\r\n        else if (moves === 1) // The one rotation may not achieve the correct orientation\r\n        {\r\n            // Rotate to correct position and check orientation.\r\n            /*\r\n            cubiesEqual = false;\r\n            rotation = CubeHeuristics.correctRotation[cubieIndex][goalIndex];\r\n            \r\n            alternateState = RubixState.copy(rubixState);\r\n            \r\n            for (var jndex = 0; jndex < rotation.length; jndex++)\r\n            {\r\n                RubixState.rotate(alternateState, rotation[jndex], rotation[++jndex]);\r\n                \r\n                if (RubixState.areCubiesEqual(rubixState, CubeHeuristics.goalState, cubieIndex))\r\n                {\r\n                    cubiesEqual = true;\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            if (!cubiesEqual)\r\n                moves += 1;\r\n            */\r\n        }\r\n        \r\n        sum += moves;\r\n    }\r\n    \r\n    // TODO - orientation - I think if the orientation doesn't match, it is still\r\n    //   admissible to assume 1 extra move is needed if its distance away is less than 1.\r\n    //   Also, the only way to do this, at least from what I can see is to perform\r\n    //   the rota2ion to correct it's position, then determine if the orientation is correct.\r\n    return sum / 4;\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfCorners = function(rubixState)\r\n{\r\n    var sum = 0, moves = 0, cubieIndex, goalIndex;//, rotation, alternateState;\r\n \r\n    for (var index = 0; index < CubeHeuristics.corners.length; index++)\r\n    {            \r\n        moves = 0;\r\n        cubieIndex = RubixState.findCubie(CubeHeuristics.goalState, CubeHeuristics.corners[index], rubixState);\r\n        goalIndex = RubixState.findCubie(rubixState, cubieIndex, CubeHeuristics.goalState);\r\n        \r\n        // If it's a far corner, need at least 2 moves to correct it's position.\r\n        if (CubeHeuristics.farCorners[cubieIndex] === goalIndex)\r\n            moves = 2;\r\n        // Otherwise, if it's not already in the correct position.\r\n        else if (cubieIndex !== goalIndex)\r\n            moves = 1;\r\n            \r\n        // Check orientation\r\n        if (moves === 0) // Correct position but not necessarily orientation\r\n        {\r\n            if (!(RubixState.areCubiesEqual(rubixState, CubeHeuristics.goalState, cubieIndex)))\r\n                moves += 2;\r\n        }\r\n        else if (moves === 1) // The one rotation may not achieve the correct orientation\r\n        {\r\n            // Rotate to correct position and check orientation.\r\n            /*\r\n            rotation = CubeHeuristics.correctRotation[cubieIndex][goalIndex];\r\n            \r\n            alternateState = RubixState.copy(rubixState);\r\n            RubixState.rotate(alternateState, rotation[0], rotation[1]);\r\n            \r\n            if (!(RubixState.areCubiesEqual(rubixState, CubeHeuristics.goalState, cubieIndex)))\r\n                moves += 1;\r\n            */\r\n        }\r\n        \r\n        sum += moves;\r\n    }\r\n    \r\n    // TODO - orientation - See above\r\n    \r\n    return sum / 4;\r\n};\r\n\r\n/**\r\n * A map defining the far corner of the given corner (i.e. the corner it will\r\n * take 2 moves to reach).\r\n */\r\nCubeHeuristics.farCorners = {\r\n    0  : 14,\r\n    2  : 12,\r\n    5  : 19,\r\n    7  : 17,\r\n    12 : 2,\r\n    14 : 0,\r\n    17 : 7,\r\n    19 : 5\r\n};\r\n\r\n/**\r\n * A map defining the far sides of the given side (i.e. the sides it will\r\n * take 2 moves to reach). They are not in any particular order.\r\n */\r\nCubeHeuristics.farSides = {\r\n    1  : [16, 15, 13, 10, 9],\r\n    3  : [10, 13, 16, 18, 11],\r\n    4  : [8, 18, 15, 9, 13],\r\n    6  : [15, 8, 18, 11, 16],\r\n    8  : [13, 16, 10, 4, 6],\r\n    9  : [1, 4, 11, 18, 16],\r\n    10 : [1, 3, 8, 15, 18],\r\n    11 : [3, 6, 9, 13, 15],\r\n    13 : [3, 8, 1, 4, 11],\r\n    15 : [1, 11, 4, 10, 6],\r\n    16 : [6, 9, 3, 8, 1],\r\n    18 : [4, 10, 6, 9, 3]\r\n};\r\n\r\n/**\r\n * A map which produces the rotation(s) needed to move the cubie at a specific location\r\n * to the following position.\r\n * \r\n * Usage: CubeHeuristics.correctRotation[current cubie location][target cubie location]\r\n * \r\n * Returns an array of [face, rotations, (face, rotations)]\r\n */\r\nCubeHeuristics.correctRotation = {\r\n    0  : {\r\n        2  : [0, 1, 5, 3],\r\n        5  : [0, 3, 1, 1],\r\n        7  : [0, 2],\r\n        12 : [1, 2],\r\n        17 : [1, 3, 5, 1],\r\n        19 : [5, 2]\r\n    },\r\n    1  : {\r\n        3  : [0, 3],\r\n        4  : [0, 1],\r\n        6  : [0, 2],\r\n        8  : [5, 1],\r\n        11 : [5, 1],\r\n        18 : [5, 2]\r\n    },\r\n    2  : {\r\n        0  : [5, 1, 0, 3],\r\n        5  : [0, 2],\r\n        7  : [0, 1, 3, 3],\r\n        14 : [3, 2],\r\n        17 : [5, 2],\r\n        19 : [5, 3, 3, 1]\r\n    },\r\n    3  : {\r\n        1  : [0, 1],\r\n        4  : [0, 2],\r\n        6  : [0, 3],\r\n        8  : [1, 3],\r\n        9  : [1, 1],\r\n        15 : [1, 2]\r\n    },\r\n    4  : {\r\n        1  : [0, 3],\r\n        3  : [0, 2],\r\n        6  : [0, 1],\r\n        10 : [3, 3],\r\n        11 : [3, 1],\r\n        16 : [3, 2]\r\n    },\r\n    5  : {\r\n        0  : [0, 1, 1, 3],\r\n        2  : [0, 2],\r\n        7  : [0, 3, 2, 1],\r\n        12 : [1, 1, 2, 3],\r\n        14 : [2, 2],\r\n        17 : [1, 2]\r\n    },\r\n    6  : {\r\n        1  : [0, 2],\r\n        3  : [0, 1],\r\n        4  : [0, 3],\r\n        9  : [2, 3],\r\n        10 : [2, 1],\r\n        13 : [2, 2]\r\n    },\r\n    7  : {\r\n        0  : [0, 2],\r\n        2  : [0, 3, 3, 1],\r\n        5  : [0, 1, 2, 3],\r\n        12 : [2, 2],\r\n        14 : [3, 3, 2, 1],\r\n        19 : [3, 2]\r\n    },\r\n    8  : {\r\n        1  : [5, 3],\r\n        3  : [1, 1],\r\n        9  : [1, 2],\r\n        11 : [5, 2],\r\n        15 : [1, 3],\r\n        18 : [5, 1]\r\n    },\r\n    9  : {\r\n        3  : [1, 3],\r\n        6  : [2, 1],\r\n        8  : [1, 2],\r\n        10 : [2, 2],\r\n        13 : [2, 3],\r\n        15 : [1, 1]\r\n    },\r\n    10 : {\r\n        4  : [3, 1],\r\n        6  : [2, 3],\r\n        9  : [2, 2],\r\n        11 : [3, 2],\r\n        13 : [2, 1],\r\n        16 : [3, 3]\r\n    },\r\n    11 : {\r\n        1  : [5, 1],\r\n        4  : [3, 3],\r\n        8  : [5, 2],\r\n        10 : [3, 2],\r\n        16 : [3, 1],\r\n        18 : [5, 3]\r\n    },\r\n    12 : {\r\n        0  : [1, 2],\r\n        5  : [2, 1, 1, 3],\r\n        7  : [2, 2],\r\n        14 : [4, 1, 2, 3],\r\n        17 : [1, 1, 4, 3],\r\n        19 : [4, 2]\r\n    },\r\n    13 : {\r\n        6  : [2, 2],\r\n        9  : [2, 1],\r\n        10 : [2, 3],\r\n        15 : [4, 3],\r\n        16 : [4, 1],\r\n        18 : [4, 2]\r\n    },\r\n    14 : {\r\n        2  : [3, 2],\r\n        5  : [2, 2],\r\n        7  : [2, 3, 3, 1],\r\n        12 : [2, 1, 4, 3],\r\n        17 : [4, 2],\r\n        19 : [4, 1, 3, 3]\r\n    },\r\n    15 : {\r\n        3  : [1, 2],\r\n        8  : [1, 1],\r\n        9  : [1, 3],\r\n        13 : [4, 1],\r\n        16 : [4, 2],\r\n        18 : [4, 3]\r\n    },\r\n    16 : {\r\n        4  : [3, 2],\r\n        10 : [3, 1],\r\n        11 : [3, 3],\r\n        13 : [4, 3],\r\n        15 : [4, 2],\r\n        18 : [4, 1]\r\n    },\r\n    17 : {\r\n        0  : [1, 1, 5, 3],\r\n        2  : [5, 2],\r\n        5  : [1, 2],\r\n        12 : [4, 1, 1, 3],\r\n        14 : [4, 2],\r\n        19 : [4, 3, 5, 1]\r\n    },\r\n    18 : {\r\n        1  : [5, 2],\r\n        8  : [5, 3],\r\n        11 : [5, 1],\r\n        13 : [4, 2],\r\n        15 : [4, 1],\r\n        16 : [4, 3]\r\n    },\r\n    19 : {\r\n        0  : [5, 2],\r\n        2  : [5, 1, 3, 3],\r\n        7  : [3, 2],\r\n        12 : [4, 2],\r\n        14 : [4, 3, 3, 1],\r\n        17 : [4, 1, 5, 3]\r\n    }\r\n};"]],"start1":0,"start2":0,"length1":0,"length2":10745}]],"length":10745}
{"contributors":[],"silentsave":false,"ts":1351115667455,"patch":[[{"diffs":[[1,"/* ----------\r\n   cubeHeuristics.js\r\n   ---------- */\r\n\r\nfunction CubeHeuristics() {}\r\n\r\nCubeHeuristics.goalState = RubixState.createWithGoalState();\r\n\r\nCubeHeuristics.corners = [0, 2, 5, 7, 12, 14, 17, 19];\r\n//6\r\nCubeHeuristics.edges = [9, 10, 13, 15, 16, 18, 1, 3, 4, 6, 8, 11];\r\n/*\r\n\r\nCubeHeuristics.edgesTop = [9, 10, 13, 15, 16, 18];\r\nCubeHeuristics.edgesBottom = [1, 3, 4, 6, 8, 11];*/\r\nCubeHeuristics.test = function()\r\n{\r\n    console.log(\"TEST\");\r\n    var rubix = RubixState.createWithGoalState();\r\n    \r\n    var face, rots;\r\n    \r\n    \r\n    for (var i = 0; i < 100; i++)\r\n    {\r\n        face = Math.floor(Math.random() * 6);\r\n        rots = Math.floor(Math.random() * 3 + 1);\r\n        \r\n        RubixState.rotate(rubix, face, rots);        \r\n    }\r\n    \r\n    //RubixState.rotate(rubix, 2, 1);\r\n    \r\n    console.log(RubixState.toString(rubix));\r\n    \r\n    var cornersH = CubeHeuristics.manhattanDistanceOfCorners(rubix);\r\n    var edgesTopH = CubeHeuristics.manhattanDistanceOfTopEdges(rubix);\r\n    var edgesBotH = CubeHeuristics.manhattanDistanceOfBottomEdges(rubix);\r\n    \r\n    console.log(\"Corners:  \" + cornersH);\r\n    console.log(\"EdgesTop: \" + edgesTopH);\r\n    console.log(\"EdgesBot: \" + edgesBotH);\r\n    console.log(\"EdgesAll: \" + CubeHeuristics.manhattanDistanceOfAllEdges(rubix));\r\n    console.log(\"Table H:  \" + Math.max(cornersH, edgesTopH, edgesBotH));\r\n};\r\n\r\nCubeHeuristics.heuristic = function(rubixState)\r\n{\r\n    return Math.max(CubeHeuristics.manhattanDistanceOfAllEdges(rubixState),\r\n                    CubeHeuristics.manhattanDistanceOfCorners(rubixState));\r\n};\r\n\r\n/* \r\nNote if a corner cubie is in the right position but the faces are wrong, it will\r\ntake at least 2 moves to right it. 3 moves for sides.\r\n*/\r\n\r\nCubeHeuristics.manhattanDistanceOfTopEdges = function(rubixState)\r\n{\r\n    return CubeHeuristics.manhattanDistanceOfEdges(rubixState, CubeHeuristics.edges,0,6);\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfBottomEdges = function(rubixState)\r\n{\r\n    return CubeHeuristics.manhattanDistanceOfEdges(rubixState, CubeHeuristics.edges,6,6);\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfAllEdges = function(rubixState)\r\n{\r\n    return CubeHeuristics.manhattanDistanceOfEdges(rubixState,CubeHeuristics.edges, 0,12) //CubeHeuristics.edgesBottom.concat(CubeHeuristics.edgesTop));\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfEdges = function(rubixState, edges,offset, size)\r\n{\r\n    var sum = 0, moves = 0, cubieIndex, goalIndex;//, rotation, alternateState, cubiesEqual;\r\n    \r\n    for (var index = offset; index < offset+size; index++)\r\n    {        \r\n        moves = 0;\r\n        \r\n        cubieIndex = RubixState.findCubie(CubeHeuristics.goalState, edges[index], rubixState);\r\n        goalIndex = RubixState.findCubie(rubixState, cubieIndex, CubeHeuristics.goalState);\r\n        \r\n        // If it's a far side, need at least 2 moves to correct it's position.\r\n        if ( CubeHeuristics.farSides[cubieIndex].indexOf(goalIndex) !== -1)\r\n            moves = 2;\r\n        // Otherwise, if it's not already in the correct position.\r\n        else if (cubieIndex !== goalIndex)\r\n            moves = 1;\r\n        \r\n        // Check orientation\r\n        if (moves === 0) // Correct position but not necessarily orientation\r\n        {\r\n            if (!(RubixState.areCubiesEqual(rubixState, CubeHeuristics.goalState, cubieIndex)))\r\n                moves += 3;\r\n        }\r\n        else if (moves === 1) // The one rotation may not achieve the correct orientation\r\n        {\r\n            // Rotate to correct position and check orientation.\r\n            /*\r\n            cubiesEqual = false;\r\n            rotation = CubeHeuristics.correctRotation[cubieIndex][goalIndex];\r\n            \r\n            alternateState = RubixState.copy(rubixState);\r\n            \r\n            for (var jndex = 0; jndex < rotation.length; jndex++)\r\n            {\r\n                RubixState.rotate(alternateState, rotation[jndex], rotation[++jndex]);\r\n                \r\n                if (RubixState.areCubiesEqual(rubixState, CubeHeuristics.goalState, cubieIndex))\r\n                {\r\n                    cubiesEqual = true;\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            if (!cubiesEqual)\r\n                moves += 1;\r\n            */\r\n        }\r\n        \r\n        sum += moves;\r\n    }\r\n    \r\n    // TODO - orientation - I think if the orientation doesn't match, it is still\r\n    //   admissible to assume 1 extra move is needed if its distance away is less than 1.\r\n    //   Also, the only way to do this, at least from what I can see is to perform\r\n    //   the rota2ion to correct it's position, then determine if the orientation is correct.\r\n    return sum / 4;\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfCorners = function(rubixState)\r\n{\r\n    var sum = 0, moves = 0, cubieIndex, goalIndex;//, rotation, alternateState;\r\n \r\n    for (var index = 0; index < CubeHeuristics.corners.length; index++)\r\n    {            \r\n        moves = 0;\r\n        cubieIndex = RubixState.findCubie(CubeHeuristics.goalState, CubeHeuristics.corners[index], rubixState);\r\n        goalIndex = RubixState.findCubie(rubixState, cubieIndex, CubeHeuristics.goalState);\r\n        \r\n        // If it's a far corner, need at least 2 moves to correct it's position.\r\n        if (CubeHeuristics.farCorners[cubieIndex] === goalIndex)\r\n            moves = 2;\r\n        // Otherwise, if it's not already in the correct position.\r\n        else if (cubieIndex !== goalIndex)\r\n            moves = 1;\r\n            \r\n        // Check orientation\r\n        if (moves === 0) // Correct position but not necessarily orientation\r\n        {\r\n            if (!(RubixState.areCubiesEqual(rubixState, CubeHeuristics.goalState, cubieIndex)))\r\n                moves += 2;\r\n        }\r\n        else if (moves === 1) // The one rotation may not achieve the correct orientation\r\n        {\r\n            // Rotate to correct position and check orientation.\r\n            /*\r\n            rotation = CubeHeuristics.correctRotation[cubieIndex][goalIndex];\r\n            \r\n            alternateState = RubixState.copy(rubixState);\r\n            RubixState.rotate(alternateState, rotation[0], rotation[1]);\r\n            \r\n            if (!(RubixState.areCubiesEqual(rubixState, CubeHeuristics.goalState, cubieIndex)))\r\n                moves += 1;\r\n            */\r\n        }\r\n        \r\n        sum += moves;\r\n    }\r\n    \r\n    // TODO - orientation - See above\r\n    \r\n    return Math.floor(sum / 4);\r\n};\r\n\r\n/**\r\n * A map defining the far corner of the given corner (i.e. the corner it will\r\n * take 2 moves to reach).\r\n */\r\nCubeHeuristics.farCorners = {\r\n    0  : 14,\r\n    2  : 12,\r\n    5  : 19,\r\n    7  : 17,\r\n    12 : 2,\r\n    14 : 0,\r\n    17 : 7,\r\n    19 : 5\r\n};\r\n\r\n/**\r\n * A map defining the far sides of the given side (i.e. the sides it will\r\n * take 2 moves to reach). They are not in any particular order.\r\n */\r\nCubeHeuristics.farSides = {\r\n    1  : [16, 15, 13, 10, 9],\r\n    3  : [10, 13, 16, 18, 11],\r\n    4  : [8, 18, 15, 9, 13],\r\n    6  : [15, 8, 18, 11, 16],\r\n    8  : [13, 16, 10, 4, 6],\r\n    9  : [1, 4, 11, 18, 16],\r\n    10 : [1, 3, 8, 15, 18],\r\n    11 : [3, 6, 9, 13, 15],\r\n    13 : [3, 8, 1, 4, 11],\r\n    15 : [1, 11, 4, 10, 6],\r\n    16 : [6, 9, 3, 8, 1],\r\n    18 : [4, 10, 6, 9, 3]\r\n};\r\n\r\n/**\r\n * A map which produces the rotation(s) needed to move the cubie at a specific location\r\n * to the following position.\r\n * \r\n * Usage: CubeHeuristics.correctRotation[current cubie location][target cubie location]\r\n * \r\n * Returns an array of [face, rotations, (face, rotations)]\r\n */\r\nCubeHeuristics.correctRotation = {\r\n    0  : {\r\n        2  : [0, 1, 5, 3],\r\n        5  : [0, 3, 1, 1],\r\n        7  : [0, 2],\r\n        12 : [1, 2],\r\n        17 : [1, 3, 5, 1],\r\n        19 : [5, 2]\r\n    },\r\n    1  : {\r\n        3  : [0, 3],\r\n        4  : [0, 1],\r\n        6  : [0, 2],\r\n        8  : [5, 1],\r\n        11 : [5, 1],\r\n        18 : [5, 2]\r\n    },\r\n    2  : {\r\n        0  : [5, 1, 0, 3],\r\n        5  : [0, 2],\r\n        7  : [0, 1, 3, 3],\r\n        14 : [3, 2],\r\n        17 : [5, 2],\r\n        19 : [5, 3, 3, 1]\r\n    },\r\n    3  : {\r\n        1  : [0, 1],\r\n        4  : [0, 2],\r\n        6  : [0, 3],\r\n        8  : [1, 3],\r\n        9  : [1, 1],\r\n        15 : [1, 2]\r\n    },\r\n    4  : {\r\n        1  : [0, 3],\r\n        3  : [0, 2],\r\n        6  : [0, 1],\r\n        10 : [3, 3],\r\n        11 : [3, 1],\r\n        16 : [3, 2]\r\n    },\r\n    5  : {\r\n        0  : [0, 1, 1, 3],\r\n        2  : [0, 2],\r\n        7  : [0, 3, 2, 1],\r\n        12 : [1, 1, 2, 3],\r\n        14 : [2, 2],\r\n        17 : [1, 2]\r\n    },\r\n    6  : {\r\n        1  : [0, 2],\r\n        3  : [0, 1],\r\n        4  : [0, 3],\r\n        9  : [2, 3],\r\n        10 : [2, 1],\r\n        13 : [2, 2]\r\n    },\r\n    7  : {\r\n        0  : [0, 2],\r\n        2  : [0, 3, 3, 1],\r\n        5  : [0, 1, 2, 3],\r\n        12 : [2, 2],\r\n        14 : [3, 3, 2, 1],\r\n        19 : [3, 2]\r\n    },\r\n    8  : {\r\n        1  : [5, 3],\r\n        3  : [1, 1],\r\n        9  : [1, 2],\r\n        11 : [5, 2],\r\n        15 : [1, 3],\r\n        18 : [5, 1]\r\n    },\r\n    9  : {\r\n        3  : [1, 3],\r\n        6  : [2, 1],\r\n        8  : [1, 2],\r\n        10 : [2, 2],\r\n        13 : [2, 3],\r\n        15 : [1, 1]\r\n    },\r\n    10 : {\r\n        4  : [3, 1],\r\n        6  : [2, 3],\r\n        9  : [2, 2],\r\n        11 : [3, 2],\r\n        13 : [2, 1],\r\n        16 : [3, 3]\r\n    },\r\n    11 : {\r\n        1  : [5, 1],\r\n        4  : [3, 3],\r\n        8  : [5, 2],\r\n        10 : [3, 2],\r\n        16 : [3, 1],\r\n        18 : [5, 3]\r\n    },\r\n    12 : {\r\n        0  : [1, 2],\r\n        5  : [2, 1, 1, 3],\r\n        7  : [2, 2],\r\n        14 : [4, 1, 2, 3],\r\n        17 : [1, 1, 4, 3],\r\n        19 : [4, 2]\r\n    },\r\n    13 : {\r\n        6  : [2, 2],\r\n        9  : [2, 1],\r\n        10 : [2, 3],\r\n        15 : [4, 3],\r\n        16 : [4, 1],\r\n        18 : [4, 2]\r\n    },\r\n    14 : {\r\n        2  : [3, 2],\r\n        5  : [2, 2],\r\n        7  : [2, 3, 3, 1],\r\n        12 : [2, 1, 4, 3],\r\n        17 : [4, 2],\r\n        19 : [4, 1, 3, 3]\r\n    },\r\n    15 : {\r\n        3  : [1, 2],\r\n        8  : [1, 1],\r\n        9  : [1, 3],\r\n        13 : [4, 1],\r\n        16 : [4, 2],\r\n        18 : [4, 3]\r\n    },\r\n    16 : {\r\n        4  : [3, 2],\r\n        10 : [3, 1],\r\n        11 : [3, 3],\r\n        13 : [4, 3],\r\n        15 : [4, 2],\r\n        18 : [4, 1]\r\n    },\r\n    17 : {\r\n        0  : [1, 1, 5, 3],\r\n        2  : [5, 2],\r\n        5  : [1, 2],\r\n        12 : [4, 1, 1, 3],\r\n        14 : [4, 2],\r\n        19 : [4, 3, 5, 1]\r\n    },\r\n    18 : {\r\n        1  : [5, 2],\r\n        8  : [5, 3],\r\n        11 : [5, 1],\r\n        13 : [4, 2],\r\n        15 : [4, 1],\r\n        16 : [4, 3]\r\n    },\r\n    19 : {\r\n        0  : [5, 2],\r\n        2  : [5, 1, 3, 3],\r\n        7  : [3, 2],\r\n        12 : [4, 2],\r\n        14 : [4, 3, 3, 1],\r\n        17 : [4, 1, 5, 3]\r\n    }\r\n};"]],"start1":0,"start2":0,"length1":0,"length2":10757}]],"length":10757,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351115691779,"patch":[[{"diffs":[[0,"urn "],[-1,"Math.floor("],[0,"sum / 4"],[-1,")"],[0,";\r\n}"]],"start1":6434,"start2":6434,"length1":27,"length2":15}]],"length":10745,"saved":false}
{"ts":1351115703012,"patch":[[{"diffs":[[0,"ct.\r\n    return "],[1,"Math.floor("],[0,"sum / 4"],[1,")"],[0,";\r\n};\r\n\r\nCubeHeu"]],"start1":4668,"start2":4668,"length1":39,"length2":51}]],"length":10757,"saved":false}
{"ts":1351115736409,"patch":[[{"diffs":[[0,"urn "],[-1,"Math.floor("],[0,"sum / 4"],[-1,")"],[0,";\r\n}"]],"start1":4680,"start2":4680,"length1":27,"length2":15}]],"length":10745,"saved":false}
{"ts":1351115753570,"patch":[[{"diffs":[[0,"s, 0,12)"],[1,";"],[0," //CubeH"]],"start1":2228,"start2":2228,"length1":16,"length2":17}]],"length":10746,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351120913917,"patch":[[{"diffs":[[0,"\r\n};"],[-1,"/* ----------\r\n   cubeHeuristics.js\r\n   ---------- */\r\n\r\nfunction CubeHeuristics() {}\r\n\r\nCubeHeuristics.goalState = RubixState.createWithGoalState();\r\n\r\nCubeHeuristics.corners = [0, 2, 5, 7, 12, 14, 17, 19];\r\n//6\r\nCubeHeuristics.edges = [9, 10, 13, 15, 16, 18, 1, 3, 4, 6, 8, 11];\r\n/*\r\n\r\nCubeHeuristics.edgesTop = [9, 10, 13, 15, 16, 18];\r\nCubeHeuristics.edgesBottom = [1, 3, 4, 6, 8, 11];*/\r\nCubeHeuristics.test = function()\r\n{\r\n    console.log(\"TEST\");\r\n    var rubix = RubixState.createWithGoalState();\r\n    \r\n    var face, rots;\r\n    \r\n    \r\n    for (var i = 0; i < 100; i++)\r\n    {\r\n        face = Math.floor(Math.random() * 6);\r\n        rots = Math.floor(Math.random() * 3 + 1);\r\n        \r\n        RubixState.rotate(rubix, face, rots);        \r\n    }\r\n    \r\n    //RubixState.rotate(rubix, 2, 1);\r\n    \r\n    console.log(RubixState.toString(rubix));\r\n    \r\n    var cornersH = CubeHeuristics.manhattanDistanceOfCorners(rubix);\r\n    var edgesTopH = CubeHeuristics.manhattanDistanceOfTopEdges(rubix);\r\n    var edgesBotH = CubeHeuristics.manhattanDistanceOfBottomEdges(rubix);\r\n    \r\n    console.log(\"Corners:  \" + cornersH);\r\n    console.log(\"EdgesTop: \" + edgesTopH);\r\n    console.log(\"EdgesBot: \" + edgesBotH);\r\n    console.log(\"EdgesAll: \" + CubeHeuristics.manhattanDistanceOfAllEdges(rubix));\r\n    console.log(\"Table H:  \" + Math.max(cornersH, edgesTopH, edgesBotH));\r\n};\r\n\r\nCubeHeuristics.heuristic = function(rubixState)\r\n{\r\n    return Math.max(CubeHeuristics.manhattanDistanceOfAllEdges(rubixState),\r\n                    CubeHeuristics.manhattanDistanceOfCorners(rubixState));\r\n};\r\n\r\n/* \r\nNote if a corner cubie is in the right position but the faces are wrong, it will\r\ntake at least 2 moves to right it. 3 moves for sides.\r\n*/\r\n\r\nCubeHeuristics.manhattanDistanceOfTopEdges = function(rubixState)\r\n{\r\n    return CubeHeuristics.manhattanDistanceOfEdges(rubixState, CubeHeuristics.edges,0,6);\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfBottomEdges = function(rubixState)\r\n{\r\n    return CubeHeuristics.manhattanDistanceOfEdges(rubixState, CubeHeuristics.edges,6,6);\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfAllEdges = function(rubixState)\r\n{\r\n    return CubeHeuristics.manhattanDistanceOfEdges(rubixState,CubeHeuristics.edges, 0,12) //CubeHeuristics.edgesBottom.concat(CubeHeuristics.edgesTop));\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfEdges = function(rubixState, edges,offset, size)\r\n{\r\n    var sum = 0, moves = 0, cubieIndex, goalIndex;//, rotation, alternateState, cubiesEqual;\r\n    \r\n    for (var index = offset; index < offset+size; index++)\r\n    {        \r\n        moves = 0;\r\n        \r\n        cubieIndex = RubixState.findCubie(CubeHeuristics.goalState, edges[index], rubixState);\r\n        goalIndex = RubixState.findCubie(rubixState, cubieIndex, CubeHeuristics.goalState);\r\n        \r\n        // If it's a far side, need at least 2 moves to correct it's position.\r\n        if ( CubeHeuristics.farSides[cubieIndex].indexOf(goalIndex) !== -1)\r\n            moves = 2;\r\n        // Otherwise, if it's not already in the correct position.\r\n        else if (cubieIndex !== goalIndex)\r\n            moves = 1;\r\n        \r\n        // Check orientation\r\n        if (moves === 0) // Correct position but not necessarily orientation\r\n        {\r\n            if (!(RubixState.areCubiesEqual(rubixState, CubeHeuristics.goalState, cubieIndex)))\r\n                moves += 3;\r\n        }\r\n        else if (moves === 1) // The one rotation may not achieve the correct orientation\r\n        {\r\n            // Rotate to correct position and check orientation.\r\n            /*\r\n            cubiesEqual = false;\r\n            rotation = CubeHeuristics.correctRotation[cubieIndex][goalIndex];\r\n            \r\n            alternateState = RubixState.copy(rubixState);\r\n            \r\n            for (var jndex = 0; jndex < rotation.length; jndex++)\r\n            {\r\n                RubixState.rotate(alternateState, rotation[jndex], rotation[++jndex]);\r\n                \r\n                if (RubixState.areCubiesEqual(rubixState, CubeHeuristics.goalState, cubieIndex))\r\n                {\r\n                    cubiesEqual = true;\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            if (!cubiesEqual)\r\n                moves += 1;\r\n            */\r\n        }\r\n        \r\n        sum += moves;\r\n    }\r\n    \r\n    // TODO - orientation - I think if the orientation doesn't match, it is still\r\n    //   admissible to assume 1 extra move is needed if its distance away is less than 1.\r\n    //   Also, the only way to do this, at least from what I can see is to perform\r\n    //   the rota2ion to correct it's position, then determine if the orientation is correct.\r\n    return sum / 4;\r\n};\r\n\r\nCubeHeuristics.manhattanDistanceOfCorners = function(rubixState)\r\n{\r\n    var sum = 0, moves = 0, cubieIndex, goalIndex;//, rotation, alternateState;\r\n \r\n    for (var index = 0; index < CubeHeuristics.corners.length; index++)\r\n    {            \r\n        moves = 0;\r\n        cubieIndex = RubixState.findCubie(CubeHeuristics.goalState, CubeHeuristics.corners[index], rubixState);\r\n        goalIndex = RubixState.findCubie(rubixState, cubieIndex, CubeHeuristics.goalState);\r\n        \r\n        // If it's a far corner, need at least 2 moves to correct it's position.\r\n        if (CubeHeuristics.farCorners[cubieIndex] === goalIndex)\r\n            moves = 2;\r\n        // Otherwise, if it's not already in the correct position.\r\n        else if (cubieIndex !== goalIndex)\r\n            moves = 1;\r\n            \r\n        // Check orientation\r\n        if (moves === 0) // Correct position but not necessarily orientation\r\n        {\r\n            if (!(RubixState.areCubiesEqual(rubixState, CubeHeuristics.goalState, cubieIndex)))\r\n                moves += 2;\r\n        }\r\n        else if (moves === 1) // The one rotation may not achieve the correct orientation\r\n        {\r\n            // Rotate to correct position and check orientation.\r\n            /*\r\n            rotation = CubeHeuristics.correctRotation[cubieIndex][goalIndex];\r\n            \r\n            alternateState = RubixState.copy(rubixState);\r\n            RubixState.rotate(alternateState, rotation[0], rotation[1]);\r\n            \r\n            if (!(RubixState.areCubiesEqual(rubixState, CubeHeuristics.goalState, cubieIndex)))\r\n                moves += 1;\r\n            */\r\n        }\r\n        \r\n        sum += moves;\r\n    }\r\n    \r\n    // TODO - orientation - See above\r\n    \r\n    return sum / 4;\r\n};\r\n\r\n/**\r\n * A map defining the far corner of the given corner (i.e. the corner it will\r\n * take 2 moves to reach).\r\n */\r\nCubeHeuristics.farCorners = {\r\n    0  : 14,\r\n    2  : 12,\r\n    5  : 19,\r\n    7  : 17,\r\n    12 : 2,\r\n    14 : 0,\r\n    17 : 7,\r\n    19 : 5\r\n};\r\n\r\n/**\r\n * A map defining the far sides of the given side (i.e. the sides it will\r\n * take 2 moves to reach). They are not in any particular order.\r\n */\r\nCubeHeuristics.farSides = {\r\n    1  : [16, 15, 13, 10, 9],\r\n    3  : [10, 13, 16, 18, 11],\r\n    4  : [8, 18, 15, 9, 13],\r\n    6  : [15, 8, 18, 11, 16],\r\n    8  : [13, 16, 10, 4, 6],\r\n    9  : [1, 4, 11, 18, 16],\r\n    10 : [1, 3, 8, 15, 18],\r\n    11 : [3, 6, 9, 13, 15],\r\n    13 : [3, 8, 1, 4, 11],\r\n    15 : [1, 11, 4, 10, 6],\r\n    16 : [6, 9, 3, 8, 1],\r\n    18 : [4, 10, 6, 9, 3]\r\n};\r\n\r\n/**\r\n * A map which produces the rotation(s) needed to move the cubie at a specific location\r\n * to the following position.\r\n * \r\n * Usage: CubeHeuristics.correctRotation[current cubie location][target cubie location]\r\n * \r\n * Returns an array of [face, rotations, (face, rotations)]\r\n */\r\nCubeHeuristics.correctRotation = {\r\n    0  : {\r\n        2  : [0, 1, 5, 3],\r\n        5  : [0, 3, 1, 1],\r\n        7  : [0, 2],\r\n        12 : [1, 2],\r\n        17 : [1, 3, 5, 1],\r\n        19 : [5, 2]\r\n    },\r\n    1  : {\r\n        3  : [0, 3],\r\n        4  : [0, 1],\r\n        6  : [0, 2],\r\n        8  : [5, 1],\r\n        11 : [5, 1],\r\n        18 : [5, 2]\r\n    },\r\n    2  : {\r\n        0  : [5, 1, 0, 3],\r\n        5  : [0, 2],\r\n        7  : [0, 1, 3, 3],\r\n        14 : [3, 2],\r\n        17 : [5, 2],\r\n        19 : [5, 3, 3, 1]\r\n    },\r\n    3  : {\r\n        1  : [0, 1],\r\n        4  : [0, 2],\r\n        6  : [0, 3],\r\n        8  : [1, 3],\r\n        9  : [1, 1],\r\n        15 : [1, 2]\r\n    },\r\n    4  : {\r\n        1  : [0, 3],\r\n        3  : [0, 2],\r\n        6  : [0, 1],\r\n        10 : [3, 3],\r\n        11 : [3, 1],\r\n        16 : [3, 2]\r\n    },\r\n    5  : {\r\n        0  : [0, 1, 1, 3],\r\n        2  : [0, 2],\r\n        7  : [0, 3, 2, 1],\r\n        12 : [1, 1, 2, 3],\r\n        14 : [2, 2],\r\n        17 : [1, 2]\r\n    },\r\n    6  : {\r\n        1  : [0, 2],\r\n        3  : [0, 1],\r\n        4  : [0, 3],\r\n        9  : [2, 3],\r\n        10 : [2, 1],\r\n        13 : [2, 2]\r\n    },\r\n    7  : {\r\n        0  : [0, 2],\r\n        2  : [0, 3, 3, 1],\r\n        5  : [0, 1, 2, 3],\r\n        12 : [2, 2],\r\n        14 : [3, 3, 2, 1],\r\n        19 : [3, 2]\r\n    },\r\n    8  : {\r\n        1  : [5, 3],\r\n        3  : [1, 1],\r\n        9  : [1, 2],\r\n        11 : [5, 2],\r\n        15 : [1, 3],\r\n        18 : [5, 1]\r\n    },\r\n    9  : {\r\n        3  : [1, 3],\r\n        6  : [2, 1],\r\n        8  : [1, 2],\r\n        10 : [2, 2],\r\n        13 : [2, 3],\r\n        15 : [1, 1]\r\n    },\r\n    10 : {\r\n        4  : [3, 1],\r\n        6  : [2, 3],\r\n        9  : [2, 2],\r\n        11 : [3, 2],\r\n        13 : [2, 1],\r\n        16 : [3, 3]\r\n    },\r\n    11 : {\r\n        1  : [5, 1],\r\n        4  : [3, 3],\r\n        8  : [5, 2],\r\n        10 : [3, 2],\r\n        16 : [3, 1],\r\n        18 : [5, 3]\r\n    },\r\n    12 : {\r\n        0  : [1, 2],\r\n        5  : [2, 1, 1, 3],\r\n        7  : [2, 2],\r\n        14 : [4, 1, 2, 3],\r\n        17 : [1, 1, 4, 3],\r\n        19 : [4, 2]\r\n    },\r\n    13 : {\r\n        6  : [2, 2],\r\n        9  : [2, 1],\r\n        10 : [2, 3],\r\n        15 : [4, 3],\r\n        16 : [4, 1],\r\n        18 : [4, 2]\r\n    },\r\n    14 : {\r\n        2  : [3, 2],\r\n        5  : [2, 2],\r\n        7  : [2, 3, 3, 1],\r\n        12 : [2, 1, 4, 3],\r\n        17 : [4, 2],\r\n        19 : [4, 1, 3, 3]\r\n    },\r\n    15 : {\r\n        3  : [1, 2],\r\n        8  : [1, 1],\r\n        9  : [1, 3],\r\n        13 : [4, 1],\r\n        16 : [4, 2],\r\n        18 : [4, 3]\r\n    },\r\n    16 : {\r\n        4  : [3, 2],\r\n        10 : [3, 1],\r\n        11 : [3, 3],\r\n        13 : [4, 3],\r\n        15 : [4, 2],\r\n        18 : [4, 1]\r\n    },\r\n    17 : {\r\n        0  : [1, 1, 5, 3],\r\n        2  : [5, 2],\r\n        5  : [1, 2],\r\n        12 : [4, 1, 1, 3],\r\n        14 : [4, 2],\r\n        19 : [4, 3, 5, 1]\r\n    },\r\n    18 : {\r\n        1  : [5, 2],\r\n        8  : [5, 3],\r\n        11 : [5, 1],\r\n        13 : [4, 2],\r\n        15 : [4, 1],\r\n        16 : [4, 3]\r\n    },\r\n    19 : {\r\n        0  : [5, 2],\r\n        2  : [5, 1, 3, 3],\r\n        7  : [3, 2],\r\n        12 : [4, 2],\r\n        14 : [4, 3, 3, 1],\r\n        17 : [4, 1, 5, 3]\r\n    }\r\n};"]],"start1":10742,"start2":10742,"length1":10749,"length2":4}]],"length":10746,"saved":false}
{"ts":1351120914912,"patch":[[{"diffs":[[0,"     }\r\n        "],[1,"        console.log(\"edge\",moves);\r\n"],[0,"\r\n        sum +="]],"start1":4267,"start2":4267,"length1":32,"length2":68}]],"length":10782,"saved":false}
{"ts":1351120927990,"patch":[[{"diffs":[[0,"   }\r\n        \r\n"],[1,"        console.log(\"corner\",moves);\r\n\r\n"],[0,"        sum += m"]],"start1":6367,"start2":6367,"length1":32,"length2":72}]],"length":10822,"saved":false}
{"ts":1351121024085,"patch":[[{"diffs":[[0,"/\r\n        }\r\n  "],[1,"//"],[0,"              co"]],"start1":4261,"start2":4261,"length1":32,"length2":34},{"diffs":[[0,"   }\r\n        \r\n"],[1,"//"],[0,"        console."]],"start1":6369,"start2":6369,"length1":32,"length2":34}]],"length":10826,"saved":false}
{"ts":1351123698596,"patch":[[{"diffs":[[0,"   }\r\n  "],[-1,"//"],[0,"        "]],"start1":4269,"start2":4269,"length1":18,"length2":16}]],"length":10824,"saved":false}
{"ts":1351123703953,"patch":[[{"diffs":[[0,"      \r\n"],[-1,"// "],[0,"       c"]],"start1":6375,"start2":6375,"length1":19,"length2":16}]],"length":10821,"saved":false}
{"ts":1351128516594,"patch":[[{"diffs":[[0,"  }\r"],[-1,"\n                console.log(\"edge\",moves);\r"],[0,"\n\r\n "]],"start1":4270,"start2":4270,"length1":52,"length2":8},{"diffs":[[0,"   \r"],[-1,"\n       console.log(\"corner\",moves);\r"],[0,"\n\r\n "]],"start1":6334,"start2":6334,"length1":45,"length2":8}]],"length":10740,"saved":false}
